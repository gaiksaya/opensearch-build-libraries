/*
 * SPDX-License-Identifier: Apache-2.0
 *
 * The OpenSearch Contributors require contributions made to
 * this file be licensed under the Apache-2.0 license or a
 * compatible open source license.
 */

import java.nio.file.Files
import java.nio.file.Paths

plugins {
    id 'com.mkobit.jenkins.pipelines.shared-library' version '0.10.1'
    id 'java'
    id 'groovy'
    id 'jacoco'
}

repositories {
    mavenCentral()
    maven { url 'https://repo.jenkins-ci.org/releases/' }
    maven { url 'https://mvnrepository.com/artifact/' }
    mavenLocal()
}

java {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}

dependencies {
    testImplementation group: 'junit', name: 'junit', version: '4.13.2'
    implementation group: 'org.codehaus.groovy', name: 'groovy-all', version: '3.0.15', ext: 'pom'
    implementation group: 'com.cloudbees', name: 'groovy-cps', version: '1.31'
    testImplementation group: 'org.yaml', name: 'snakeyaml', version: '2.0'
    testImplementation group: 'org.assertj', name: 'assertj-core', version: '3.24.2'
    testImplementation group: 'com.lesfurets', name:'jenkins-pipeline-unit', version: '1.20'
    testImplementation group: 'org.mockito', name: 'mockito-core', version: '5.12.0'
}

configurations.all {
    resolutionStrategy {
        force group: 'com.google.code.gson', name: 'gson', version: '2.8.9'
        force group: 'commons-codec', name: 'commons-codec', version: '1.15'
        force group: 'com.google.protobuf', name: 'protobuf-java', version: '3.25.5'
        force group: 'com.google.errorprone', name: 'error_prone_annotations', version: '2.18.0'
        force group: 'org.checkerframework', name: 'checker-qual', version: '3.33.0'
        force group: 'com.google.j2objc', name: 'j2objc-annotations', version: '2.8'
        force group: 'org.jenkins-ci.plugins', name: 'durable-task', version: '547.vd1ea_007d100c'
    }
}

def classPathDumpsDir = "$buildDir/jacoco/classpathdumps"
def parsedClassPathDumpsDir = "$buildDir/jacoco/parsedclasspathdumps"

sourceSets {
    main {
        groovy {
            srcDirs = ['src/jenkins', 'src/gradlecheck', 'src/utils']
        }
    }

    test {
        groovy {
            srcDirs = ['tests/jenkins', 'tests/gradlecheck']
        }
    }

    jobs {
        groovy {
            srcDirs 'src/jenkins/jobs'
            compileClasspath += main.compileClasspath
        }

        compileClasspath += sourceSets.main.output
        runtimeClasspath += sourceSets.main.output
    }
}

sharedLibrary {
    coreVersion = '2.426.3' // https://repo.jenkins-ci.org/public/org/jenkins-ci/main/jenkins-core/
    testHarnessVersion = '2085.va_c531db_287b_d' // https://mvnrepository.com/artifact/org.jenkins-ci.main/jenkins-test-harness?repo=jenkins-releases
    pluginDependencies {
        workflowCpsGlobalLibraryPluginVersion = '570.v21311f4951f8' // https://repo.jenkins-ci.org/public/org/jenkins-ci/plugins/workflow/workflow-cps-global-lib/
        // see https://mvnrepository.com/artifact/org.jenkins-ci.plugins/<name>?repo=jenkins-releases for latest
        dependency('org.jenkins-ci.plugins.workflow', 'workflow-cps', '3606.v0b_d8b_e512dcf')
        dependency('org.jenkins-ci.plugins.workflow', 'workflow-multibranch', '2.26.1')
        dependency('org.jenkins-ci.plugins', 'pipeline-input-step', '456.vd8a_957db_5b_e9') // https://repo.jenkins-ci.org/public/org/jenkins-ci/plugins/pipeline-input-step/
        dependency('org.jenkins-ci.plugins', 'script-security', '1229.v4880b_e905a_6')
        dependency('org.jenkins-ci.plugins', 'credentials', '1112.vc87b_7a_3597f6')
        dependency('org.jenkins-ci.plugins', 'git-client', '3.11.1')
        dependency('org.jenkins-ci.plugins', 'junit', '1312.v1a_235a_b_94a_31')
        dependency('org.jenkins-ci.plugins', 'mailer', '408.vd726a_1130320') // https://repo.jenkins-ci.org/public/org/jenkins-ci/plugins/mailer/
    }
}

jacoco {
    toolVersion = '0.8.7'
}

test {
    testLogging {
        events "failed"
        exceptionFormat "full"
    }
    if (project.hasProperty('pipeline.stack.write')) {
        systemProperty 'pipeline.stack.write', project.getProperty('pipeline.stack.write')
    }

    jacoco {
        classDumpDir = file(classPathDumpsDir)
    }

    finalizedBy jacocoTestReport
}

jacocoTestReport {
    dependsOn test

    sourceSets sourceSets.main

    reports {
        xml.required = true
        html.required = false
        xml.destination file("${buildDir}/reports/jacoco/xml/${System.getProperty('coverageFileName', 'jacoco.xml')}")
    }

    afterEvaluate {
            classDirectories.from = fileTree(
                dir: "${System.getProperty('coverageClassesDir', sourceSets.main.groovy.outputDir.path)}",
                includes: [
                        '**/*_Jenkinsfile.*',
                        '**/jenkins/*',
                        '**/gradlecheck/*',
                        '**/utils/*'
                ],
                excludes: [
                        '**/*\$_get_closure*'
                ]
            )
    }
}

task jacocoParseClassDumps {
    doFirst {
        cleanClassPathDumps(classPathDumpsDir)
        parseClassPathDumps(classPathDumpsDir, parsedClassPathDumpsDir)
    }
}

task jacocoTestReports {
    def classesDirs = []

    classesDirs << "${sourceSets.main.groovy.outputDir}"

    if (file(parsedClassPathDumpsDir).exists()) {
        file(parsedClassPathDumpsDir).eachFile {
            classesDirs << it.path
        }
    }

    dependsOn classesDirs.collect { "runJacocoWith${file(it).name}" }

    classesDirs.each {
        def targetDir = file(it)
        def targetDirName = targetDir.name
        def targetDirPath = targetDir.path
        def targetFileName = targetDirName + '.xml'
        task "runJacocoWith${targetDirName}"(type: GradleBuild) {
            buildFile = 'build.gradle'
            tasks = ['jacocoTestReport']
            startParameter.systemPropertiesArgs += [coverageFileName: targetFileName, coverageClassesDir: targetDirPath]
        }
    }
}

String version = '8.2.1'

task updateVersion {
    doLast {
        println "Setting version to ${version} in all libraries"
        ant.replaceregexp(match:'jenkins@main', replace: 'jenkins@' + version, flags: 'g') {
            fileset(dir: projectDir) {
                include (name: "vars/**")
                include (name: "tests/**")
            }
        }
    }
}

// --------------------------------------------------
// Helper functions

/**
 * Collects all the source file paths from all the source folders specified in the project configuration.
 *
 * @return A list of all the source file paths relative to the root package and excluding the
 * extensions (i.e. [foo, mypackage/bar])
 */
def getAllSourceFilePaths() {
    def sourceFilePaths = []
    def baseDirs = sourceSets.main.groovy.srcDirs
    baseDirs.each { File baseDir ->
        fileTree(dir: baseDir).each { File file ->
            sourceFilePaths << file.path.replace(baseDir.path + '/', '').replace('.groovy', '')
        }
    }

    return sourceFilePaths
}

/**
 * Cleans the class path dump directory by deleting class files that were not compiled from the source files (i.e. class
 * files from external libraries, etc).
 *
 * @param classPathDumpsDir Path to the class dumps directory seen by the Jacoco agent.
 */
def cleanClassPathDumps(String classPathDumpsDir) {
    def srcFilePaths = getAllSourceFilePaths()
    fileTree(dir: classPathDumpsDir).each { File file ->
        def filePath = file.path.replace(classPathDumpsDir + '/', '')
        def cleanedFilePath = filePath.contains('$') ? filePath.tokenize('$')[0] : filePath.tokenize('.')[0]
        if (!srcFilePaths.contains(cleanedFilePath) || file.path.contains('$')) {
            file.delete()
        }
    }
}

/**
 * Check whether the class is already duplicated in the specified directory.
 *
 * @param baseDir Path to the directory containing the classes to check.
 * @param relativeFilePath Relative path of the class file to check for duplication.
 *
 * @return True if there is already a class file with the same class as the one we are checking, or False otherwise.
 */
def isClassDuplicatedInDir(String baseDir, String relativeFilePath) {
    for (File file in fileTree(dir: baseDir)) {
        def cleanRelativeFilePath = relativeFilePath.contains('$') ? relativeFilePath.tokenize('$')[0] : relativeFilePath.tokenize('.')[0]
        if (file.path.contains("${baseDir}/${cleanRelativeFilePath}")) {
            return true
        }
    }
    return false
}

/**
 * Parses the class dump directory seen by the Jacoco agent by copying duplicated file names to individual folders. If
 * this is not done, then at the time of analysis it will throw 'Can't add different class with same name' error since
 * the Jenkins unit testing framework dynamically creates different class files for the same class at runtime.
 *
 * @param classPathDumpsDir Path to the class files dump directory from the Jacoco agent.
 * @param parsedClassPathDumpsDir Path to the base directory that will contain the sub-directories containing the parsed
 * class files.
 */
def parseClassPathDumps(String classPathDumpsDir, String parsedClassPathDumpsDir) {
    def classesBaseTree = fileTree(dir: classPathDumpsDir)
    for (File srcFile in classesBaseTree) {
        for (int i = 1 ; i <= classesBaseTree.size() ; i++) {
            def targetDir = "${parsedClassPathDumpsDir}/${i}"
            if (Files.notExists(Paths.get(targetDir))) {
                Files.createDirectories(Paths.get(targetDir))
            }

            def relativeTargetFilePath = srcFile.path.replace(classPathDumpsDir + '/', '')
            def targetFile = file("${targetDir}/${relativeTargetFilePath}")

            if (!isClassDuplicatedInDir(targetDir, relativeTargetFilePath)) {
                def targetParentPath = Paths.get(targetFile.parent)
                if (Files.notExists(targetParentPath)) {
                    Files.createDirectories(targetParentPath)
                }
                Files.copy(Paths.get(srcFile.path), Paths.get(targetFile.path))
                break
            }
        }
    }
}